================================================================================
ALL-IN-DOCKER ARCHITECTURE DOCUMENTATION
Web3 Indexer - Industrial-Grade Containerized Deployment
================================================================================

ğŸ—ï¸ ARCHITECTURE OVERVIEW
================================================================================

This is the final, standard, industrial-grade architecture decision:
ALL COMPONENTS FULLY CONTAINERIZED (All-in-Docker)
Communication via Docker service names (zero configuration)

This achieves:
âœ… Zero configuration
âœ… Zero environment dependencies  
âœ… One-click deployment
âœ… Maximum portability
âœ… Go language static compilation advantages


ğŸ“¦ SERVICE TOPOLOGY
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Docker Compose Network                       â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚                      â”‚ â”‚
â”‚  â”‚   Database   â”‚  â”‚   Anvil RPC  â”‚  â”‚     Indexer (Go)     â”‚ â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚                      â”‚ â”‚
â”‚  â”‚ Service: db  â”‚  â”‚Service: anvilâ”‚  â”‚ Service: indexer     â”‚ â”‚
â”‚  â”‚ Port: 5432   â”‚  â”‚ Port: 8545   â”‚  â”‚ Port: 8080           â”‚ â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚                      â”‚ â”‚
â”‚  â”‚ postgres:15  â”‚  â”‚ foundry:     â”‚  â”‚ Go binary (compiled) â”‚ â”‚
â”‚  â”‚ -alpine      â”‚  â”‚ latest       â”‚  â”‚                      â”‚ â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚ Exposed: 8080 â†’ Host â”‚ â”‚
â”‚  â”‚ Internal     â”‚  â”‚ Internal     â”‚  â”‚                      â”‚ â”‚
â”‚  â”‚ only         â”‚  â”‚ only         â”‚  â”‚                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ”Œ COMMUNICATION MATRIX
================================================================================

Service Name Resolution (Docker DNS):
  - db:5432        â†’ PostgreSQL database
  - anvil:8545     â†’ Anvil RPC node
  - indexer:8080   â†’ Indexer API/Dashboard

External Access:
  - http://localhost:8080  â†’ Indexer API/Dashboard
  - All other services are internal only (no port exposure)


âš™ï¸ CONFIGURATION APPROACH
================================================================================

Go Indexer Configuration (Zero Configuration):

DATABASE_URL=postgres://postgres:postgres@db:5432/web3_indexer?sslmode=disable
  â†‘ Uses Docker service name 'db' instead of localhost
  â†‘ No IP address needed
  â†‘ No port mapping required

RPC_URLS=http://anvil:8545
  â†‘ Uses Docker service name 'anvil' instead of localhost
  â†‘ No IP address needed
  â†‘ No port mapping required

CHAIN_ID=31337
  â†‘ Anvil local chain ID

START_BLOCK=0
  â†‘ Start from genesis for local testing

API_PORT=8080
  â†‘ Exposed to host


ğŸ“‹ FILES STRUCTURE
================================================================================

docker-compose.yml
  â””â”€ Main service definitions (all-in-Docker)
     â”œâ”€ db service (PostgreSQL)
     â”œâ”€ anvil service (Foundry Anvil)
     â””â”€ indexer service (Go binary)

Dockerfile
  â””â”€ Multi-stage build for Go indexer
     â”œâ”€ Stage 1: Build (golang:1.21-alpine)
     â””â”€ Stage 2: Runtime (alpine:latest)

.env.docker
  â””â”€ Environment variables for Docker deployment
     â”œâ”€ Database configuration
     â”œâ”€ RPC configuration
     â”œâ”€ Chain configuration
     â””â”€ Logging configuration

docker-compose.dev.yml
  â””â”€ Development overrides
     â”œâ”€ Debug logging
     â”œâ”€ Volume mounts
     â””â”€ Verbose output

scripts/
  â”œâ”€ docker-deploy.sh       - Deployment automation
  â”œâ”€ docker-health-check.sh - Health monitoring
  â”œâ”€ docker-logs.sh         - Log viewer
  â””â”€ docker-shell.sh        - Container shell access


ğŸš€ DEPLOYMENT WORKFLOW
================================================================================

Step 1: Clean up old containers
  $ docker compose down -v

Step 2: Build and start all services
  $ docker compose up -d --build

Step 3: Wait for services to be ready
  $ sleep 10

Step 4: Verify health
  $ curl http://localhost:8080/healthz

Step 5: Access dashboard
  $ open http://localhost:8080

Automated (recommended):
  $ make deploy


ğŸ”§ KEY CONFIGURATION POINTS
================================================================================

1. Service Names (Docker DNS)
   - All services communicate via service names
   - No localhost/127.0.0.1 needed
   - No dynamic IP address resolution
   - Automatic DNS resolution within Docker network

2. Health Checks
   - Database: pg_isready command
   - Indexer: HTTP /healthz endpoint
   - Anvil: JSON-RPC eth_chainId method

3. Dependency Management
   - Indexer depends on db (condition: service_healthy)
   - Indexer depends on anvil (condition: service_started)
   - Ensures correct startup order

4. Network Isolation
   - All services on 'web3-network' bridge network
   - Database and Anvil not exposed to host
   - Only Indexer API exposed (port 8080)

5. Data Persistence
   - PostgreSQL data stored in 'postgres_data' volume
   - Survives container restarts
   - Can be cleaned with 'docker compose down -v'


ğŸ“Š RESOURCE ALLOCATION
================================================================================

Database (PostgreSQL):
  - Image: postgres:15-alpine (~150 MB)
  - Memory: ~100-200 MB at rest
  - Storage: Dynamic (migrations + data)

Anvil RPC:
  - Image: ghcr.io/foundry-rs/foundry:latest (~500 MB)
  - Memory: ~200-300 MB
  - Storage: Ephemeral (in-memory state)

Indexer (Go):
  - Image: ~50-100 MB (multi-stage build)
  - Memory: ~100-300 MB (depends on workload)
  - Storage: Minimal (no persistent state)

Total footprint: ~700-1000 MB images + runtime memory


ğŸ” SECURITY CONSIDERATIONS
================================================================================

âœ… Database
  - Only accessible within Docker network
  - No external port exposure
  - Credentials in environment variables
  - Can be hardened with .pgpass

âœ… Anvil RPC
  - Only accessible within Docker network
  - No external port exposure
  - Local chain (31337) for testing only

âœ… Indexer API
  - Single exposed port (8080)
  - Can be restricted with firewall rules
  - Health endpoint for monitoring
  - No sensitive data in logs (configurable)

âœ… Secrets Management
  - Database password in environment variables
  - Can be injected from .env file
  - Can use Docker secrets for production
  - Never hardcoded in Dockerfile


ğŸ¯ ADVANTAGES OF THIS ARCHITECTURE
================================================================================

1. Zero Configuration
   âœ… Service names handle all networking
   âœ… No localhost/IP address configuration
   âœ… No port mapping complexity
   âœ… Environment variables injected at runtime

2. Zero Environment Dependencies
   âœ… No need to install PostgreSQL locally
   âœ… No need to install Anvil locally
   âœ… No need to install Go locally
   âœ… Only Docker required

3. One-Click Deployment
   âœ… Single command: make deploy
   âœ… Automatic service orchestration
   âœ… Health checks and readiness probes
   âœ… Proper dependency management

4. Maximum Portability
   âœ… Works on any machine with Docker
   âœ… Same behavior on dev/staging/production
   âœ… No environment-specific configuration
   âœ… git clone â†’ docker compose up

5. Go Language Advantages
   âœ… Static compilation to single binary
   âœ… Minimal Docker image size
   âœ… Fast startup time (~1-2 seconds)
   âœ… No runtime dependencies
   âœ… Perfect for containerization

6. Production-Ready
   âœ… Multi-stage Docker build
   âœ… Health checks for all services
   âœ… Proper restart policies
   âœ… Resource limits (configurable)
   âœ… Logging and monitoring hooks


ğŸ”„ LIFECYCLE MANAGEMENT
================================================================================

Start Services:
  $ make deploy
  or
  $ docker compose up -d --build

Stop Services:
  $ docker compose down

Clean Everything:
  $ docker compose down -v

Restart Services:
  $ docker compose restart

View Logs:
  $ docker compose logs -f

Check Status:
  $ docker compose ps

Access Database:
  $ ./scripts/docker-shell.sh db

Access Container:
  $ ./scripts/docker-shell.sh indexer


ğŸ“ˆ SCALING CONSIDERATIONS
================================================================================

Current Setup (Single Instance):
  - One database instance
  - One Anvil RPC node
  - One indexer instance

For Production Scaling:
  - Use managed database (RDS, Cloud SQL)
  - Use managed RPC provider (Alchemy, Infura)
  - Scale indexer with load balancer
  - Use container orchestration (Kubernetes)

For High Availability:
  - Database replication
  - Multiple RPC providers with failover
  - Horizontal scaling of indexer
  - Distributed state management


ğŸ“ BEST PRACTICES IMPLEMENTED
================================================================================

âœ… Multi-stage Docker builds
   - Reduces image size
   - Separates build and runtime dependencies
   - Faster deployment

âœ… Alpine Linux base
   - Minimal image size (~5 MB)
   - Security patches
   - Fast startup

âœ… Health checks
   - Automatic service monitoring
   - Dependency ordering
   - Readiness probes

âœ… Environment variables
   - Configuration management
   - Secret injection
   - Runtime flexibility

âœ… Volume management
   - Data persistence
   - Proper cleanup
   - Backup capability

âœ… Network isolation
   - Service-to-service communication
   - Minimal external exposure
   - Security by default

âœ… Logging
   - Structured logging
   - Log aggregation ready
   - Debug mode available


ğŸš€ DEPLOYMENT CHECKLIST
================================================================================

Pre-Deployment:
  â˜ Docker installed and running
  â˜ Docker Compose installed
  â˜ Sufficient disk space (~2 GB)
  â˜ Ports 8080 available

Deployment:
  â˜ Run: make deploy
  â˜ Wait for services to start
  â˜ Check health: curl http://localhost:8080/healthz
  â˜ Access dashboard: http://localhost:8080

Post-Deployment:
  â˜ Verify all services running: docker compose ps
  â˜ Check logs: docker compose logs
  â˜ Monitor health: ./scripts/docker-health-check.sh
  â˜ Test API endpoints

Maintenance:
  â˜ Regular health checks
  â˜ Log monitoring
  â˜ Database backups
  â˜ Security updates


================================================================================
This is the FINAL, STANDARD, INDUSTRIAL-GRADE architecture for Go Indexer.
It represents the perfect convergence of Go's static compilation advantages
with Docker's containerization benefits.

Deployment: git clone â†’ make deploy â†’ Done! ğŸš€
================================================================================
